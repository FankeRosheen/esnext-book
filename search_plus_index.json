{"./":{"url":"./","title":"前言","keywords":"","body":" ECMAScript Next 系列教程 说明 ECMAScript Next 系列教程，是对 ECMAScript 新特性的整理学习笔记。 如果你读完本教程有收获，请帮忙传播，让更多人受益。如果有不妥之处，欢迎提 MR 更正。 目录 作者 木子朗 Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2020-11-30 01:59:53 "},"es2020/es2020.html":{"url":"es2020/es2020.html","title":"ECMAScript 2020 (ES11)","keywords":"","body":"Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2020-11-30 01:59:53 "},"es2020/string-matchall.html":{"url":"es2020/string-matchall.html","title":"String.prototype.matchAll","keywords":"","body":"String.prototype.matchAll 简介 ES2020 增加了 String.prototype.matchAll() 方法，可以一次性取出所有匹配。该方法返回遍历器，相对于数组，如果匹配结果是一个很大的数组，那么遍历器比较节省资源。 语法 str.matchAll(regexp) 参数 regexp：正则表达式对象。如果所传参数不是一个正则表达式对象，则会隐式地使用 new RegExp(obj) 将其转换为一个 RegExp。RegExp 必须是设置了全局模式 g 的形式，否则会抛出异常 TypeError。 返回值 一个迭代器（不可重用，结果耗尽需要再次调用方法，获取一个新的迭代器）。 实例 Regexp.exec() 和 matchAll() 在 matchAll 出现之前，通过在循环中调用 regexp.exec() 来获取所有匹配项信息（regexp 需使用 /g 标志） const regexp = RegExp('foo[a-z]*', 'g') const str = 'table football, foosball' let match while ((match = regexp.exec(str)) !== null) { console.log(`Found ${match[0]} start=${match.index} end=${regexp.lastIndex}.`) } // expected output: \"Found football start=6 end=14.\" // expected output: \"Found foosball start=16 end=24.\" 使用 matchAll 会得到一个迭代器的返回值，配合 for...of, array spread, 或者 Array.from() 可以更方便实现功能 const regexp = RegExp('foo[a-z]*', 'g') const str = 'table football, foosball' const matches = str.matchAll(regexp) Array.from(str.matchAll(regexp), (m) => m[0]) // Array [ \"football\", \"foosball\" ] 如果没有 /g 标志，matchAll 会抛出异常。 const regexp = RegExp('[a-c]', '') const str = 'abc' Array.from(str.matchAll(regexp), (m) => m[0]) // TypeError: String.prototype.matchAll called with a non-global RegExp argument matchAll 相比 match 可以获取捕获组 当使用 match() 和 /g 标志方式获取匹配信息时，捕获组会被忽略 var regexp = /t(e)(st(\\d?))/g var str = 'test1test2' str.match(regexp) // Array ['test1', 'test2'] 使用 matchAll 可以通过如下方式获取分组捕获 let array = [...str.matchAll(regexp)] array[0] // ['test1', 'e', 'st1', '1', index: 0, input: 'test1test2', length: 4] array[1] // ['test2', 'e', 'st2', '2', index: 5, input: 'test1test2', length: 4] Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2020-11-30 01:59:53 "},"es2020/dynamic-import.html":{"url":"es2020/dynamic-import.html","title":"Dynamic Import","keywords":"","body":"import() 函数 简介 import 命令被 JavaScript 引擎静态分析，先于模块内的其他语句执行，无法取代 require() 的动态加载功能，提案建议引入与 require 方法类似的 import 方法。 语法 import(specifier) 上面代码中，import 函数的参数 specifier，指定所要加载的模块的位置。import 命令能够接受什么参数，import() 函数就能接受什么参数，两者区别主要是后者为动态加载。 返回值 import() 返回一个 Promise 对象。来看一个官方例子。 Books Movies Video Games Content will load here! const main = document.querySelector('main') for (const link of document.querySelectorAll('nav > a')) { link.addEventListener('click', (e) => { e.preventDefault() import(`./section-modules/${link.dataset.entryModule}.js`) .then((module) => { module.loadPageInto(main) }) .catch((err) => { main.textContent = err.message }) }) } 上面的代码，import()函数是运行时执行，类似于 Node 的 require 方法，区别主要是前者是异步加载，后者是同步加载。 实例 按需加载 button.addEventListener('click', (event) => { import('./dialogBox.js') .then((dialogBox) => { dialogBox.open() }) .catch((error) => { /* Error handling */ }) }) 上面代码中，import()方法放在 click 事件的监听函数之中，只有用户点击了按钮，才会加载这个模块。 条件加载 if (condition) { import('moduleA').then(...); } else { import('moduleB').then(...); } import()可以放在 if 代码块，根据不同的情况，加载不同的模块。 动态的模块路径 import(f()) .then(...); 上面代码中，根据函数 f 的返回结果，加载不同的模块。 在 async 函数中使用 async function main() { const myModule = await import('./myModule.js') const { export1, export2 } = await import('./myModule.js') const [module1, module2, module3] = await Promise.all([ import('./module1.js'), import('./module2.js'), import('./module3.js'), ]) } 参考 proposal-dynamic-importModule 的语法 - ECMAScript 6 入门 Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2020-11-30 01:59:53 "},"es2020/bigint.html":{"url":"es2020/bigint.html","title":"BigInt","keywords":"","body":"BigInt 简介 JavaScript 所有数字都保存成 64 位浮点数，这给数值的表示带来了很大限制。一是数值的精度只能到 53 个二进制（相当于 16 个十进制位），大于这个范围的整数，JavaScript 是无法精确表示的，这使得 JavaScript 不适合进行科学和金融方面的精确计算。二是大于或等于 2 的 1024 次方的数值，JavaScript 无法表示，会返回 Infinity。 ES2020 引入了一种新的数据类型 BigInt（大整数），来解决这个问题，这是 ECMAScript 的第八种数据类型。BigInt 只用来表示整数，没有位数的限制，任何位数的整数都可以精确表示。 语法 定义一个 BigInt 可以用在一个整数字面量后面加 n 的方式定义一个 BigInt。 const a = 9007199254740991n 调用函数 BigInt()。 const b = BigInt(9007199254740991) 类型判断 使用 typeof 判断类型，BigInt 对象返回 \"bigint\" typeof 1n === 'bigint' // true typeof BigInt('1') === 'bigint' // true 使用 Object 包装后， BigInt 被认为是一个普通 \"object\" typeof Object(1n) === 'object' // true 类型转换 可以使用 Boolean()、Number()和 String()这三个方法，将 BigInt 可以转为布尔值、数值和字符串类型。 Boolean(0n) // false Boolean(1n) // true Number(1n) // 1 String(1n) // \"1\" 另外，取反运算符（!）也可以将 BigInt 转为布尔值。 !0n // true !1n // false 运算 以下操作符可以和 BigInt 一起使用： +、*、-、**、% 。除 >>>（无符号右移）之外的位操作也可以支持。因为 BigInt 都是有符号的， >>>（无符号右移）不能用于 BigInt。为了兼容 asm.js，BigInt 不支持单目 (+) 运算符。 除法运算 / 结果会向零取整，也就是说不会返回小数部分。 const expected = 4n / 2n // 2n const rounded = 5n / 2n // 2n, not 2.5n BigInt 不能与普通数值进行混合运算。 1n + 1.3 // 报错 上面代码报错是因为无论返回的是 BigInt 或 Number，都会导致丢失精度信息。比如 (2n**53n + 1n) + 0.5 这个表达式，如果返回 BigInt 类型，0.5 这个小数部分会丢失；如果返回 Number 类型，有效精度只能保持 53 位，导致精度下降。 同样的原因，如果一个标准库函数的参数预期是 Number 类型，但是得到的是一个 BigInt，就会报错。 // 错误的写法 Math.sqrt(4n) // 报错 // 正确的写法 Math.sqrt(Number(4n)) // 2 上面代码中，Math.sqrt 的参数预期是 Number 类型，如果是 BigInt 就会报错，必须先用 Number 方法转一下类型，才能进行计算。 比较 BigInt 和 Number 不是严格相等的，但是宽松相等的。 0n === 0 // false 0n == 0 // true 两者也可以混在一个数组内并排序。 const mixed = [4n, 6, -12n, 10, 4, 0, 0n] // [4n, 6, -12n, 10, 4, 0, 0n] mixed.sort() // [-12n, 0, 0n, 10, 4n, 4, 6] 条件 BigInt 转换成 Boolean 的时表现跟 Number 类似。 if (0n) { console.log('Hello from the if!') } else { console.log('Hello from the else!') } // \"Hello from the else!\" 0n || 12n // 12n 0n && 12n // 0n Boolean(0n) // false Boolean(12n) // true !12n // false !0n // true 静态方法 BigInt.asIntN() 将 BigInt 值转换为一个 -2width-1 与 2width-1-1 之间的有符号整数。 BigInt.asUintN() 将一个 BigInt 值转换为 0 与 2width-1 之间的无符号整数。 BigInt.parseInt() 近似于Number.parseInt()，将一个字符串转换成指定进制的 BigInt。 实例方法 BigInt 对象继承了 Object 对象的两个实例方法。 BigInt.prototype.toString() BigInt.prototype.valueOf() 继承了 Number 对象的一个实例方法。 BigInt.prototype.toLocaleString() 参考 proposal-bigint数值的扩展 - ECMAScript 6 入门BigInt - JavaScript | MDN Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2020-11-30 01:59:53 "},"es2020/promise-allSettled.html":{"url":"es2020/promise-allSettled.html","title":"Promise.allSettled","keywords":"","body":"Promise.allSettled 简介 如果等待多个 promise 返回结果，我们可以用 Promise.all([promise_1, promise_2])。但是该方法如果其中一个请求失败了，就会抛出错误。有时候我们希望某个请求失败后，其他请求的结果能够正常返回。针对这种情况 ES2020 引入了 Promise.allSettled() 方法 。 语法 Promise.allSettled()方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只有等到所有这些参数实例都返回结果，不管是 fulfilled 还是 rejected，包装实例才会结束。 const promise1 = Promise.resolve(3) const promise2 = new Promise((resolve, reject) => setTimeout(reject, 100, 'foo')) const promises = [promise1, promise2] Promise.allSettled(promises).then((results) => results.forEach((result) => console.log(result))) // Object { status: \"fulfilled\", value: 3 } // Object { status: \"rejected\", reason: \"foo\" } 该方法返回的新的 Promise 实例，一旦结束，状态总是 fulfilled，不会变成 rejected。状态变成 fulfilled 后，Promise 的监听函数接收到的参数是一个数组，该数组的每个成员都是一个对象，对应传入 Promise.allSettled()的两个 Promise 实例。每个对象都有 status 属性，该属性的值只可能是字符串 fulfilled 或字符串 rejected。fulfilled 时，对象有 value 属性，rejected 时有 reason 属性，对应两种状态的返回值。 有时候，我们不关心异步操作的结果，只关心这些操作有没有结束。这时，Promise.allSettled()方法就很有用。 参考 Promise.allSettled Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2020-11-30 01:59:53 "},"es2020/global.html":{"url":"es2020/global.html","title":"globalThis","keywords":"","body":"globalThis 对象 简介 JavaScript 语言存在一个顶层对象，它提供全局环境（即全局作用域），所有代码都是在这个环境中运行。但是，顶层对象在各种实现里面是不统一的。在 Web 中，可以通过 window、self 或者 frames 取到全局对象，但是在 Web Workers 中，只有 self 可以。在 Node.js 中，它们都无法获取，必须使用 global。 同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用 this 变量，但是有局限性。 全局环境中，this 会返回顶层对象。但是，Node.js 模块中 this 返回的是当前模块，ES6 模块中 this 返回的是 undefined。 函数里面的 this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this 会指向顶层对象。但是，严格模式下，这时 this 会返回 undefined。 不管是严格模式，还是普通模式，new Function('return this')()，总是会返回全局对象。虽然可以通过此方式获取全局对象，但是，如果浏览器用了 CSP（Content Security Policy，内容安全策略），那么 eval、new Function 这些方法都可能无法使用。 ES2020 引入了 globalThis 作为顶层对象。也就是说，在任何环境下，都可以通过 globalThis 来拿到顶层对象。 示例 在 globalThis 出现之前 var getGlobal = function () { if (typeof self !== 'undefined') { return self } if (typeof window !== 'undefined') { return window } if (typeof global !== 'undefined') { return global } throw new Error('unable to locate global object') } var globals = getGlobal() if (typeof globals.setTimeout !== 'function') { // 此环境中没有 setTimeout 方法！ } 有了 globalThis 之后 if (typeof globalThis.setTimeout !== 'function') { // 此环境中没有 setTimeout 方法！ } 参考 globalThislet 和 const 命令 - ECMAScript 6 入门 Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2020-11-30 01:59:53 "},"es2020/for-in-order.html":{"url":"es2020/for-in-order.html","title":"for-in mechanics","keywords":"","body":"Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2020-11-30 01:59:53 "},"es2020/optional-chaining.html":{"url":"es2020/optional-chaining.html","title":"Optional Chaining","keywords":"","body":"Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2020-11-30 01:59:53 "},"es2020/nullish-coalescing.html":{"url":"es2020/nullish-coalescing.html","title":"Nullish coalescing Operator","keywords":"","body":"Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2020-11-30 01:59:53 "},"es2020/import-meta.html":{"url":"es2020/import-meta.html","title":"import.meta","keywords":"","body":"Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2020-11-30 01:59:53 "},"es2017/es2017.html":{"url":"es2017/es2017.html","title":"ECMAScript 2017 (ES8)","keywords":"","body":"ES 2017 Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2020-11-30 01:59:53 "},"es2017/async-await.html":{"url":"es2017/async-await.html","title":"Async / Await","keywords":"","body":"Async / Await 简介 在 ES2015 中引入了 Promise 来解决“回调地域”的问题。时隔两年，ES2017 Async Functions 的出现，证明 Promise 不是最终的解决方案。 ES2017 标准引入了 Async Functions 的概念，使得异步操作变得更加方便。Async Functions 是 Generator 函数的语法糖，直观上看，async 函数就是将 Generator 函数的星号（*）替换成 async，将 yield 替换成 await，仅此而已。 async 和 await，比起星号和 yield，语义更加清晰，更符合语义。并且 async 函数自带执行器，不需要像 Generator 函数一样，需要调用 next 方法，或者用 co 模块。async 函数的返回值是 Promise 对象，其内部可以看做是多个异步操作，包装成的一个 Promise 对象，而 await 命令是内部 then 命令的语法糖。 语法 返回 Promise 对象 async 函数返回一个 Promise 对象，如果代码中返回的是非 Promise 对象，JavaScript 会自动将其包装成 Promise.resolved() 的值。 async function test() { return 'hello world' } test().then((v) => console.log(v)) // \"hello world\" 也可以显示的返回一个 Promise，结果与上面例子相同。 async function test() { return Promise.resolve('hello world') } test().then((v) => console.log(v)) // \"hello world\" 如果 async 函数内部抛出错误，会导致返回的 Promise 对象变为 reject 状态。抛出的错误会被 catch 方法捕获到。 async function test() { throw new Error('出错了') } test().then( (v) => console.log('resolve', v), (e) => console.log('reject', e), ) //reject Error: 出错了 await 命令 await 命令只能在 async 函数内部使用。 一般情况下， await 命令后面是一个 Promise 对象，返回该对象的结果。如果不是，就直接返回对应的值。 async function test() { return await 'hello world' // 等同于 // return 'hello world' } test().then((v) => console.log(v)) // \"hello world\" 另一种情况是， await 接收一个 thenable 对象（具有可调用 then 方法的对象），那么 await 会将其等同于 Promise 对象。 class Thenable { constructor(num) { this.num = num } then(resolve, reject) { setTimeout(() => resolve(this.num * 2), 1000) } } ;(async () => { const result = await new Thenable(2) console.log(result) })() // 4 上面例子中， await 得到了一个带有 then 方法的非 Promise 对象，它会调用提供原生函数的 resolve、reject 作为参数的方法。 错误处理 如果一个 Promise 正常 resolve，那么 await 会返回这个结果，但是在 reject 的情况下会抛出一个错误。 async function test() { await Promise.reject(new Error('出错了！')) } test() .then((v) => console.log(v)) .catch((e) => console.log(e)) // Error：出错了 注意，和下面写法效果一样。 async function test() { throw new Error('出错了！') } 任何一个 await 语句后面的 Promise 对象变为 reject 状态，那么整个 async 函数都会中断执行。 async function test() { await Promise.reject(new Error('出错了')) await Promise.resolve('hello world') // 不会执行 } 有时，我们希望即使一个异步操作失败，也不会中断后面的异步操作。可以将前面的 await 放在 try...catch 语句中。 async function test() { try { await Promise.reject(new Error('出错了')) } catch (e) { console.error(e) // Error: 出错了 } return await Promise.resolve('hello world') } test().then((v) => console.log(v)) // hello world 如果发生了错误，会被 catch 捕获到。当然如果有多个 await 命令，可以统一放在 try...catch 语句中处理。 Promise 对象的状态变化 使用注意点 实例 按顺序完成异步操作 实际开发中，经常遇到一组异步操作，如一组网络请求，需要按顺序完成，然后按照顺序输出结果。 Promise 写法如下。 function logInOrder(urls) { // 远程读取所有URL const textPromises = urls.map((url) => { return fetch(url).then((response) => response.text()) }) // 按次序输出 textPromises.reduce((chain, textPromise) => { return chain.then(() => textPromise).then((text) => console.log(text)) }, Promise.resolve()) } 上面代码使用 fetch 方法，请求一组 URL。每个 fetch 都会返回一个 Promise 对象，放入 textPromises 数组。然后，使用 reduce 方法依次处理每个 Promise 对象，然后使用 then 将所有 Promise 对象连接起来，依次输出结果。 下面用 async 函数改造。 async function logInOrder(urls) { for (const url of urls) { const response = await fetch(url) console.log(await response.text()) } } 上面代码简洁了很多，问题是所有 fetch 操作都是继发，效率很差。并发改造如下。 async function logInOrder(urls) { // 并发读取远程URL const textPromises = urls.map(async (url) => { const response = await fetch(url) return response.text() }) // 按次序输出 for (const textPromise of textPromises) { console.log(await textPromise) } } 上面代码中，虽然 map 方法的参数是 async 函数，但它是并发执行的，因为只有 async 函数内部是继发执行，外部不受影响。后面的 for..of 循环内部使用了 await，因此实现了按顺序输出。 休眠效果 JavaScript 一直没有休眠的语法，但是借助 await 命令可以让程序停顿指定的时间。 function sleep(interval) { return new Promise((resolve) => { setTimeout(resolve, interval) }) } // 用法 async function log() { for (let i = 1; i 使用 try...catch 结构，实现多次重复尝试 在实际开发中，有时当由于网络等原因导致请求报错，我们期望请求能够重试指定的次数。 const NUM_RETRIES = 3 async function test() { let i for (i = 0; i 参考 async 函数 - ECMAScript 6 入门Async Functions for ECMAScript Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2020-11-30 01:59:53 "},"es2017/sharedmem.html":{"url":"es2017/sharedmem.html","title":"Shared Memory and Atomics","keywords":"","body":"Shared Memory and Atomics 简介 ECMAScript 2017 引入了一个新的构造函数 SharedArrayBuffer 和 具有辅助函数的命名空间对象 Atomics。 语法 SharedArrayBuffer JavaScript 是单线程，Web worker 引入了多线程：主线程用来与用户互动，Worker 线程用来承担计算任务。每个线程的数据都是隔离的，通过 postMessage() 通信。 // 主线程 const w = new Worker('worker.js') w.postMessage('hello') w.onmessage = function (ev) { console.log(ev.data) } // worker.js onmessage = function (ev) { console.log(ev.data) postMessage('hi') } 上面代码中，主线程创建了一个 Woker 线程，该线程与主线程之间通过 postMessage() 通信。 线程之间的数据交换可以是各种格式，这种数据交换采用复制机制，即一个进程将要分享的数据复制一份，通过 postMessage 方法发送给另一个进程。如果数据量较大，通信的效率会明显较低。共享内存的方式，会大大提高效率。 SharedArrayBuffer 对象用来表示一个通用的，固定长度的原始二进制数据缓冲区，类似于 ArrayBuffer 对象，唯一的区别是后者无法共享数据。 new SharedArrayBuffer(length) 参数 length：所创建的数组缓冲区的大小，以字节(byte)为单位。 返回值 一个大小指定的新 SharedArrayBuffer 对象。其内容被初始化为 0。 示例 // 主线程 // 新建 1KB 共享内存 const sharedBuffer = new SharedArrayBuffer(1024) // 主线程将共享内存的地址发送出去 w.postMessage(sharedBuffer) // 在共享内存上建立视图，供写入数据 const sharedArray = new Int32Array(sharedBuffer) // Worker 线程 onmessage = function (ev) { // 主线程共享的数据，就是 1KB 的共享内存 const sharedBuffer = ev.data // 在共享内存上建立视图，方便读写 const sharedArray = new Int32Array(sharedBuffer) // ... } 共享内存也可以在 Worker 线程创建，发给主线程。 注意： SharedArrayBuffer 与 ArrayBuffer 一样，本身是无法读写的，必须在上面建立视图，然后通过视图读写。 Atomics 多线程共享内存，最大的问题就是防止两个线程同时修改某个地址，或者说，当一个线程修改共享内存以后，必须有一个机制让其他线程同步。SharedArrayBuffer API 提供 Atomics 对象，保证所有共享内存的操作都是“原子性”的，并且可以在所有线程内同步。 原子操作：多个共享内存的线程能够同时读写同一位置上的数据。原子操作会确保正在读或写的数据的值是符合预期的，即下一个原子操作一定会在上一个原子操作结束后才会开始，其操作过程不会中断。 与一般的全局对象不同，Atomics 不是构造函数，因此不能使用 new 操作符调用，也不能将其当作函数直接调用。Atomics 的所有属性和方法都是静态的（与 Math 对象一样）。 方法 Atomics.store()，Atomics.load() store() 方法用来向共享内存写入数据，并返回该值。 load() 方法用来从共享内存读出数据。 Atomics.store(typedArray, index, value)Atomics.load(typedArray, index) typedArray 一个指定类型的 shared 数组. 类型为 Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, 或者 Uint32Array 其中一个。 index typedArray 中用来存储 value 的位置。 value 要存储的数字。 var sab = new SharedArrayBuffer(1024) var ta = new Uint8Array(sab) Atomics.store(ta, 0, 12) // 12 Atomics.load(ta, 0) // 12 Atomics.exchange() 将数组中指定的元素更新为给定的值，并返回该元素更新前的值。 Atomics.exchange(typedArray, index, value) var sab = new SharedArrayBuffer(1024) var ta = new Uint8Array(sab) Atomics.exchange(ta, 0, 12) // returns 0, the old value Atomics.load(ta, 0) // 12 Atomics.wait()，Atomics.notify() 这两个方法相当于锁内存，即在一个线程进行操作时，让其他线程休眠（建立锁），等到操作结束，再唤醒那些休眠的线程（解除锁）。 Atomics.wait(typedArray, index, value[, timeout]) typedArray 一个共享的 Int32Array。 index typedArray 中要唤醒的目标索引。 value 给定需要检测的位置索引的预期值。 timeout 可选，超时前等待的毫秒数。 Infinity, 如未提供该参数，将为无穷大。 Atomics.notify(typedArray, index, count) count 要通知的正在休眠的代理的数量。默认是 +Infinity。 返回值 一个 String 字符串，值为 \"ok\", \"not-equal\", 或 \"timed-out\" 三种之一。 如果 sharedArray[index] 不等于 value，就返回字符串 not-equal，否则就进入休眠。如果 Atomics.notify() 方法唤醒，就返回字符串 ok；如果因为超时唤醒，就返回字符串 timed-out。 // Worker 线程 self.addEventListener( 'message', (event) => { const sharedArray = new Int32Array(event.data) const arrayIndex = 0 const expectedStoredValue = 50 Atomics.wait(sharedArray, arrayIndex, expectedStoredValue) console.log(Atomics.load(sharedArray, arrayIndex)) }, false, ) 上面代码中，Atomics.wait() 方法等同于告诉 Worker 线程，只要满足给定条件（sharedArray 的 0 号位置等于 50），就在这一行 Worker 线程进入休眠。 // 主线程 const newArrayValue = 100 Atomics.store(sharedArray, 0, newArrayValue) const arrayIndex = 0 const queuePos = 1 Atomics.notify(sharedArray, arrayIndex, queuePos) 上面代码中，sharedArray 的 0 号位置改为 100，然后就执行 Atomics.notify()方法，唤醒在 sharedArray 的 0 号位置休眠队列里的一个线程。 注意，浏览器的主线程不宜设置休眠，这会导致用户失去响应。而且，主线程实际上会拒绝进入休眠。 Atomics.add() 将指定位置上的数组元素与给定的值相加，并返回相加前该元素的值。 Atomics.add(typedArray, index, value) var sab = new SharedArrayBuffer(1024) var ta = new Uint8Array(sab) Atomics.add(ta, 0, 12) // returns 0, the old value Atomics.load(ta, 0) // 12 Atomics.and() 将指定位置上的数组元素与给定的值相与，并返回与操作前该元素的值。 Atomics.and(typedArray, index, value) var sab = new SharedArrayBuffer(1024) var ta = new Uint8Array(sab) ta[0] = 5 Atomics.and(ta, 0, 1) // returns 0, the old value Atomics.load(ta, 0) // 1 Atomics.compareExchange() 如果数组中指定的元素与给定的值相等，则将其更新为新的值，并返回该元素原先的值。 Atomics.compareExchange(typedArray, index, expectedValue, replacementValue) expectedValue 用于比较的值。 replacementValue 将要替换上的值。 var sab = new SharedArrayBuffer(1024) var ta = new Uint8Array(sab) ta[0] = 7 Atomics.compareExchange(ta, 0, 7, 12) // returns 7, the old value Atomics.load(ta, 0) // 12 Atomics.isLockFree() 返回一个布尔值，表示 Atomics 对象是否可以处理某个 size 的内存锁定。如果返回 false，应用程序就需要自己来实现锁定。 Atomics.isLockFree(size) Atomics.isLockFree(1) // true Atomics.isLockFree(2) // true Atomics.isLockFree(3) // false Atomics.isLockFree(4) // true Atomics.isLockFree(5) // false Atomics.isLockFree(6) // false Atomics.isLockFree(7) // false Atomics.isLockFree(8) // false Atomics.isLockFree(Float64Array.BYTES_PER_ELEMENT) // false,Atomics方法无法处理Float64Array Atomics.or() 将指定位置上的数组元素与给定的值相或，并返回或操作前该元素的值。 Atomics.or(typedArray, index, value) var sab = new SharedArrayBuffer(1024) var ta = new Uint8Array(sab) ta[0] = 2 Atomics.or(ta, 0, 1) // returns 2, the old value Atomics.load(ta, 0) // 3 Atomics.sub() 将指定位置上的数组元素与给定的值相减，并返回相减前该元素的值。 Atomics.sub(typedArray, index, value) const sab = new SharedArrayBuffer(1024) const ta = new Uint8Array(sab) ta[0] = 48 Atomics.sub(ta, 0, 12) // returns 48, the old value Atomics.load(ta, 0) // 36 Atomics.xor() 将指定位置上的数组元素与给定的值相异或，并返回异或操作前该元素的值。 Atomics.xor(typedArray, index, value) const sab = new SharedArrayBuffer(1024) const ta = new Uint8Array(sab) ta[0] = 5 Atomics.xor(ta, 0, 1) // returns 5, the old value Atomics.load(ta, 0) // 4 参考 Shared memory and atomics for ECMAscriptArrayBuffer - ECMAScript 6 入门SharedArrayBufferAtomics Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2020-11-30 01:59:53 "},"es2017/object-values-entries.html":{"url":"es2017/object-values-entries.html","title":"Object.values / Object.entries","keywords":"","body":"Object.values / Object.entries 简介 在 Object 中，ES2017 新增了两个新的函数，分别是 Object.values 函数和 Object.entries 函数。 Object.values() 方法返回一个给定对象自身的所有可枚举属性值的数组，值的顺序与使用 for...in 循环的顺序相同（区别在于 for-in 循环枚举原型链中的属性）。 Object.entries() 方法返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for...in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环还会枚举原型链中的属性）。 两者枚举属性的顺序与通过手动循环对象的属性值所给出的顺序相同，如果属性名为数值的属性，是按照数值大小，从小到大遍历的。 语法 Object.values() 属性值为字符串 const obj = { foo: 'bar', baz: 'test' } Object.values(obj) // [\"bar\", \"test\"] 属性值为数字 const obj = { 666: 'a', 2: 'b', 8: 'c' } Object.values(obj) // [\"b\", \"c\", \"a\"] 上面例子中，属性名为数值，按照数值大小遍历，因此返回的顺序是 b、c、a。 只返回对象本身的可遍历属性 const obj = Object.create({}, { p: { value: 42 } }) Object.values(obj) // [] 上面代码中，Object.create 方法的第二个参数添加的对象属性 enumerable 默认是 false，Object.values 不会返回这个属性。只要把 enumerable 改成 true，Object.values 就会返回属性 p 的值。 const obj = Object.create( {}, { p: { value: 42, enumerable: true, }, }, ) Object.values(obj) // [42] 属性值为 Symbol Object.values({ [Symbol()]: 123, foo: 'abc' }) // ['abc'] Object.values 会过滤属性名为 Symbol 值的属性。 参数不是对象 如果 Object.values 方法的参数是一个字符串，会返回各个字符组成的一个数组。 Object.values('foo') // ['f', 'o', 'o'] 如果参数不是对象，Object.values 会先将其转为对象。 由于数值和布尔值的包装对象，都不会为实例添加非继承的属性。所以，Object.values 会返回空数组。 Object.values(42) // [] Object.values(true) // [] Object.entries() 除了返回值不一样，该方法的行为与 Object.values 基本一致。 遍历对象的属性 const obj = { a: 5, b: 7, c: 9 } for (const [key, value] of Object.entries(obj)) { console.log(`${key}: ${value}`) } // \"a: 5\", \"b: 7\", \"c: 9\" 将 Object 转为 Map 结构 new Map() 构造函数接受一个可迭代的 entries。借助 Object.entries 方法你可以很容易的将 Object 转换为 Map: var obj = { foo: 'bar', baz: 42 } var map = new Map(Object.entries(obj)) console.log(map) // Map { foo: \"bar\", baz: 42 } 参考 Objet.values()Object.entries()对象的新增方法 - ECMAScript 6 入门 Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2020-11-30 01:59:53 "},"es2017/string-pad-start-end.html":{"url":"es2017/string-pad-start-end.html","title":"String padding","keywords":"","body":"String padding 简介 在 String 对象中，ES2017 增加了两个新的函数，字符串补全长度功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart() 用于头部补全，padEnd() 用于尾部补全。 语法 str.padStart(targetLength [, padString])str.padEnd(targetLength [, padString]) 参数： targetLength：当前字符串需要填充到的目标长度。如果这个数值小于当前字符串的长度，则返回当前字符串本身。 padString：可选，填充字符串。此参数的默认值为 \" \"。 返回值： 在原字符串开头填充指定的填充字符串直到目标长度所形成的新字符串。 实例 原字符串的长度，等于或大于最大长度，则字符串补全不生效，返回原字符串。 'xxx'.padStart(2, 'ab') // 'xxx' 'xxx'.padEnd(2, 'ab') // 'xxx' 如果用来补全的字符串与原字符串，两者的长度之和超过了最大长度，则会截去超出位数的补全字符串。 'abc'.padStart(10, '0123456789') // '0123456abc' 如果省略第二个参数，默认使用空格补全长度。 'x'.padStart(4) // ' x' 'x'.padEnd(4) // 'x ' 参考 String.prototype.padStart / String.prototype.padEnd Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2020-11-30 01:59:53 "},"es2017/trailing-function-commas.html":{"url":"es2017/trailing-function-commas.html","title":"Trailing comma","keywords":"","body":"函数参数列表结尾允许逗号 简介 ES2017 允许函数的最后一个参数有尾逗号（trailing comma）。此前，函数定义和调用时，都不允许最后一个参数后面出现逗号。 语法 function clownPuppiesEverywhere( param1, + param2 // this line ) { /* ... */ } clownPuppiesEverywhere( 'foo', + 'bar' // this line ) 上面代码中，如果修改代码添加第三个参数，或者调整参数的次序，就要在原来最后一个参数的后面添加逗号，对于版本管理来说，就会显示添加逗号的那一行发生了变动。看上去又写冗余。 function clownPuppiesEverywhere( param1, param2, // this line ) { /* ... */ } clownPuppiesEverywhere( 'foo', 'bar', // this line ) 这样的规定也使得，函数参数与数组和对象的尾逗号规则，保持一致了。 参考 Proposal to allow trailing commas in function parameter lists Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2020-11-30 01:59:53 "},"es2017/object-getownpropertydescriptors.html":{"url":"es2017/object-getownpropertydescriptors.html","title":"Object.getOwnPropertyDescriptors","keywords":"","body":"Object.getOwnPropertyDescriptors 简介 ES5 的 Object.getOwnPropertyDescriptor() 方法会返回某个对象属性的描述对象（descriptor）。ES2017 引入了 Object.getOwnPropertyDescriptors() 方法，返回指定对象所有自身属性（非继承属性）的描述对象。 语法 基本用法如下。 const obj = { foo: 123, get bar() { return 'abc' }, } Object.getOwnPropertyDescriptors(obj) // { foo: // { value: 123, // writable: true, // enumerable: true, // configurable: true }, // bar: // { get: [Function: get bar], // set: undefined, // enumerable: true, // configurable: true } } 该方法的实现非常容易。 function getOwnPropertyDescriptors(obj) { const result = {} for (let key of Reflect.ownKeys(obj)) { result[key] = Object.getOwnPropertyDescriptor(obj, key) } return result } 该方法引入的目的，主要是为了解决 Object.assign() 无法正确拷贝 get 属性和 set 属性的问题。Object.assign 方法总是拷贝一个属性的值，而不会拷贝它背后的赋值方法或取值方法。 这时，Object.getOwnPropertyDescriptors() 方法配合 Object.defineProperties() 方法，就可以实现正确拷贝。 const source = { set foo(value) { console.log(value) }, } const target2 = {} Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source)) Object.getOwnPropertyDescriptor(target2, 'foo') // { get: undefined, // set: [Function: set foo], // enumerable: true, // configurable: true } 实例 浅拷贝一个对象 配合 Object.create() 方法，将对象属性克隆到一个新对象。 Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj)) 创建子类 创建子类的典型方法是定义子类，将其原型设置为超类的实例，然后在该实例上定义属性。这么写很不优雅，特别是对于 getters 和 setter 而言。可以下面方式设置原型： function superclass() {} superclass.prototype = { // 在这里定义方法和属性 } function subclass() {} subclass.prototype = Object.create( superclass.prototype, Object.getOwnPropertyDescriptors({ // 在这里定义方法和属性 }), ) 参考 对象的新增方法 - ECMAScript 6 入门tc39/Object.getOwnPropertyDescriptors Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2020-11-30 01:59:53 "},"es2016/es2016.html":{"url":"es2016/es2016.html","title":"ECMAScript 2016 (ES7)","keywords":"","body":"ES 2016 Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2020-11-30 01:59:53 "},"es2016/array-prototype-includes.html":{"url":"es2016/array-prototype-includes.html","title":"Array.prototype.includes","keywords":"","body":"Array.prototype.includes() 简介 includes() 方法用来判断一个数组是否包含一个指定的值。如果包含则返回 true，否则返回 false。 语法 arr.includes(valueToFind[, fromIndex]) valueToFind 需要查找的元素值。 fromIndex 可选，从 fromIndex 索引处开始查找 valueToFind。如果为负值，则按升序从 array.length + fromIndex 的索引开始搜 （即使从末尾开始往前跳 fromIndex 的绝对值个索引，然后往后搜寻）。默认为 0。 示例 基本使用 [1, 2, 3].includes(2) // true [1, 2, 3].includes(4) // false [1, 2, 3].includes(3, 3) // false [1, 2, 3].includes(3, -1) // true [1, 2, NaN)].includes(NaN) // true fromIndex 大于等于数组长度 如果 fromIndex 大于等于数组的长度，则会返回 false，且该数组不会被搜索。 var arr = ['a', 'b', 'c'] arr.includes('c', 3) // false arr.includes('c', 100) // false 计算出的索引小于 0 如果 fromIndex 为负值，计算出的索引将作为开始搜索 searchElement 的位置。如果计算出的索引小于 0，则整个数组都会被搜索。 // array length is 3 // fromIndex is -100 // computed index is 3 + (-100) = -97 var arr = ['a', 'b', 'c'] arr.includes('a', -100) // true arr.includes('b', -100) // true arr.includes('c', -100) // true arr.includes('a', -2) // false 参考 Array.prototype.includes Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2020-11-30 01:59:53 "},"es2016/proposal-exponentiation-operator.html":{"url":"es2016/proposal-exponentiation-operator.html","title":"求幂运算符(**)","keywords":"","body":"求幂运算符(**) 语法 求幂运算符 ** 等价于 Math.pow()，但是它被引入语言本身，而不是库函数。 Math.pow(x, y) // 9 let squared = 3 ** 2 // 9 let num = 3 num **= 2 console.log(num) // 9 参考 Exponentiation Operator Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2020-11-30 01:59:53 "}}