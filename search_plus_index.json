{"./":{"url":"./","title":"前言","keywords":"","body":"简介 Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2020-11-10 02:15:46 "},"es2016/es2016.html":{"url":"es2016/es2016.html","title":"ECMAScript 2016 (ES7)","keywords":"","body":"ES 2016 sdfds Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2020-11-10 02:15:46 "},"es2016/array-prototype-includes.html":{"url":"es2016/array-prototype-includes.html","title":"Array.prototype.includes","keywords":"","body":"Array.prototype.includes() 简介 includes() 方法用来判断一个数组是否包含一个指定的值。如果包含则返回 true，否则返回 false。 语法 arr.includes(valueToFind[, fromIndex]) valueToFind 需要查找的元素值。 fromIndex 可选，从 fromIndex 索引处开始查找 valueToFind。如果为负值，则按升序从 array.length + fromIndex 的索引开始搜 （即使从末尾开始往前跳 fromIndex 的绝对值个索引，然后往后搜寻）。默认为 0。 示例 基本使用 [1, 2, 3].includes(2) // true [1, 2, 3].includes(4) // false [1, 2, 3].includes(3, 3) // false [1, 2, 3].includes(3, -1) // true [1, 2, NaN)].includes(NaN) // true fromIndex 大于等于数组长度 如果 fromIndex 大于等于数组的长度，则会返回 false，且该数组不会被搜索。 var arr = ['a', 'b', 'c'] arr.includes('c', 3) // false arr.includes('c', 100) // false 计算出的索引小于 0 如果 fromIndex 为负值，计算出的索引将作为开始搜索 searchElement 的位置。如果计算出的索引小于 0，则整个数组都会被搜索。 // array length is 3 // fromIndex is -100 // computed index is 3 + (-100) = -97 var arr = ['a', 'b', 'c'] arr.includes('a', -100) // true arr.includes('b', -100) // true arr.includes('c', -100) // true arr.includes('a', -2) // false 参考 Array.prototype.includes Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2020-11-10 02:15:46 "},"es2016/proposal-exponentiation-operator.html":{"url":"es2016/proposal-exponentiation-operator.html","title":"求幂运算符(**)","keywords":"","body":"求幂运算符(**) 语法 求幂运算符 ** 等价于 Math.pow()，但是它被引入语言本身，而不是库函数。 Math.pow(x, y) // 9 let squared = 3 ** 2 // 9 let num = 3 num **= 2 console.log(num) // 9 参考 Exponentiation Operator Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2020-11-10 02:15:46 "},"es2017/es2017.html":{"url":"es2017/es2017.html","title":"ECMAScript 2017 (ES8)","keywords":"","body":"ES 2017 Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2020-11-10 02:15:46 "},"es2017/async-await.html":{"url":"es2017/async-await.html","title":"Async / Await","keywords":"","body":"Async / Await 简介 在 ES2015 中引入了 Promise 来解决“回调地域”的问题。时隔两年，ES2017 Async Functions 的出现，证明 Promise 不是最终的解决方案。 ES2017 标准引入了 Async Functions 的概念，使得异步操作变得更加方便。Async Functions 是 Generator 函数的语法糖，直观上看，async 函数就是将 Generator 函数的星号（*）替换成 async，将 yield 替换成 await，仅此而已。 async 和 await，比起星号和 yield，语义更加清晰，更符合语义。并且 async 函数自带执行器，不需要像 Generator 函数一样，需要调用 next 方法，或者用 co 模块。async 函数的返回值是 Promise 对象，其内部可以看做是多个异步操作，包装成的一个 Promise 对象，而 await 命令是内部 then 命令的语法糖。 语法 返回 Promise 对象 async 函数返回一个 Promise 对象，如果代码中返回的是非 Promise 对象，JavaScript 会自动将其包装成 Promise.resolved() 的值。 async function test() { return 'hello world' } test().then((v) => console.log(v)) // \"hello world\" 也可以显示的返回一个 Promise，结果与上面例子相同。 async function test() { return Promise.resolve('hello world') } test().then((v) => console.log(v)) // \"hello world\" 如果 async 函数内部抛出错误，会导致返回的 Promise 对象变为 reject 状态。抛出的错误会被 catch 方法捕获到。 async function test() { throw new Error('出错了') } test().then( (v) => console.log('resolve', v), (e) => console.log('reject', e), ) //reject Error: 出错了 await 命令 await 命令只能在 async 函数内部使用。 一般情况下， await 命令后面是一个 Promise 对象，返回该对象的结果。如果不是，就直接返回对应的值。 async function test() { return await 'hello world' // 等同于 // return 'hello world' } test().then((v) => console.log(v)) // \"hello world\" 另一种情况是， await 接收一个 thenable 对象（具有可调用 then 方法的对象），那么 await 会将其等同于 Promise 对象。 class Thenable { constructor(num) { this.num = num } then(resolve, reject) { setTimeout(() => resolve(this.num * 2), 1000) } } ;(async () => { const result = await new Thenable(2) console.log(result) })() // 4 上面例子中， await 得到了一个带有 then 方法的非 Promise 对象，它会调用提供原生函数的 resolve、reject 作为参数的方法。 错误处理 如果一个 Promise 正常 resolve，那么 await 会返回这个结果，但是在 reject 的情况下会抛出一个错误。 async function test() { await Promise.reject(new Error('出错了！')) } test() .then((v) => console.log(v)) .catch((e) => console.log(e)) // Error：出错了 注意，和下面写法效果一样。 async function test() { throw new Error('出错了！') } 任何一个 await 语句后面的 Promise 对象变为 reject 状态，那么整个 async 函数都会中断执行。 async function test() { await Promise.reject(new Error('出错了')) await Promise.resolve('hello world') // 不会执行 } 有时，我们希望即使一个异步操作失败，也不会中断后面的异步操作。可以将前面的 await 放在 try...catch 语句中。 async function test() { try { await Promise.reject(new Error('出错了')) } catch (e) { console.error(e) // Error: 出错了 } return await Promise.resolve('hello world') } test().then((v) => console.log(v)) // hello world 如果发生了错误，会被 catch 捕获到。当然如果有多个 await 命令，可以统一放在 try...catch 语句中处理。 Promise 对象的状态变化 使用注意点 实例 按顺序完成异步操作 实际开发中，经常遇到一组异步操作，如一组网络请求，需要按顺序完成，然后按照顺序输出结果。 Promise 写法如下。 function logInOrder(urls) { // 远程读取所有URL const textPromises = urls.map((url) => { return fetch(url).then((response) => response.text()) }) // 按次序输出 textPromises.reduce((chain, textPromise) => { return chain.then(() => textPromise).then((text) => console.log(text)) }, Promise.resolve()) } 上面代码使用 fetch 方法，请求一组 URL。每个 fetch 都会返回一个 Promise 对象，放入 textPromises 数组。然后，使用 reduce 方法依次处理每个 Promise 对象，然后使用 then 将所有 Promise 对象连接起来，依次输出结果。 下面用 async 函数改造。 async function logInOrder(urls) { for (const url of urls) { const response = await fetch(url) console.log(await response.text()) } } 上面代码简洁了很多，问题是所有 fetch 操作都是继发，效率很差。并发改造如下。 async function logInOrder(urls) { // 并发读取远程URL const textPromises = urls.map(async (url) => { const response = await fetch(url) return response.text() }) // 按次序输出 for (const textPromise of textPromises) { console.log(await textPromise) } } 上面代码中，虽然 map 方法的参数是 async 函数，但它是并发执行的，因为只有 async 函数内部是继发执行，外部不受影响。后面的 for..of 循环内部使用了 await，因此实现了按顺序输出。 休眠效果 JavaScript 一直没有休眠的语法，但是借助 await 命令可以让程序停顿指定的时间。 function sleep(interval) { return new Promise((resolve) => { setTimeout(resolve, interval) }) } // 用法 async function log() { for (let i = 1; i 使用 try...catch 结构，实现多次重复尝试 在实际开发中，有时当由于网络等原因导致请求报错，我们期望请求能够重试指定的次数。 const NUM_RETRIES = 3 async function test() { let i for (i = 0; i 参考 async 函数 - ECMAScript 6 入门Async Functions for ECMAScript Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2020-11-10 02:15:46 "},"es2017/sharedmem.html":{"url":"es2017/sharedmem.html","title":"Shared Memory and Atomics","keywords":"","body":"Shared Memory and Atomics 简介 ECMAScript 2017 引入了一个新的构造函数 SharedArrayBuffer 和 具有辅助函数的命名空间对象 Atomics。 语法 SharedArrayBuffer JavaScript 是单线程，Web worker 引入了多线程：主线程用来与用户互动，Worker 线程用来承担计算任务。每个线程的数据都是隔离的，通过 postMessage() 通信。 // 主线程 const w = new Worker('worker.js') w.postMessage('hello') w.onmessage = function (ev) { console.log(ev.data) } // worker.js onmessage = function (ev) { console.log(ev.data) postMessage('hi') } 上面代码中，主线程创建了一个 Woker 线程，该线程与主线程之间通过 postMessage() 通信。 线程之间的数据交换可以是各种格式，这种数据交换采用复制机制，即一个进程将要分享的数据复制一份，通过 postMessage 方法发送给另一个进程。如果数据量较大，通信的效率会明显较低。共享内存的方式，会大大提高效率。 SharedArrayBuffer 对象用来表示一个通用的，固定长度的原始二进制数据缓冲区，类似于 ArrayBuffer 对象，唯一的区别是后者无法共享数据。 new SharedArrayBuffer(length) 参数 length：所创建的数组缓冲区的大小，以字节(byte)为单位。 返回值 一个大小指定的新 SharedArrayBuffer 对象。其内容被初始化为 0。 示例 // 主线程 // 新建 1KB 共享内存 const sharedBuffer = new SharedArrayBuffer(1024) // 主线程将共享内存的地址发送出去 w.postMessage(sharedBuffer) // 在共享内存上建立视图，供写入数据 const sharedArray = new Int32Array(sharedBuffer) // Worker 线程 onmessage = function (ev) { // 主线程共享的数据，就是 1KB 的共享内存 const sharedBuffer = ev.data // 在共享内存上建立视图，方便读写 const sharedArray = new Int32Array(sharedBuffer) // ... } 共享内存也可以在 Worker 线程创建，发给主线程。 注意： SharedArrayBuffer 与 ArrayBuffer 一样，本身是无法读写的，必须在上面建立视图，然后通过视图读写。 Atomics 多线程共享内存，最大的问题就是防止两个线程同时修改某个地址，或者说，当一个线程修改共享内存以后，必须有一个机制让其他线程同步。SharedArrayBuffer API 提供 Atomics 对象，保证所有共享内存的操作都是“原子性”的，并且可以在所有线程内同步。 原子操作：多个共享内存的线程能够同时读写同一位置上的数据。原子操作会确保正在读或写的数据的值是符合预期的，即下一个原子操作一定会在上一个原子操作结束后才会开始，其操作过程不会中断。 与一般的全局对象不同，Atomics 不是构造函数，因此不能使用 new 操作符调用，也不能将其当作函数直接调用。Atomics 的所有属性和方法都是静态的（与 Math 对象一样）。 方法 Atomics.store()，Atomics.load() store() 方法用来向共享内存写入数据，并返回该值。 load() 方法用来从共享内存读出数据。 Atomics.store(typedArray, index, value)Atomics.load(typedArray, index) typedArray 一个指定类型的 shared 数组. 类型为 Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, 或者 Uint32Array 其中一个。 index typedArray 中用来存储 value 的位置。 value 要存储的数字。 var sab = new SharedArrayBuffer(1024) var ta = new Uint8Array(sab) Atomics.store(ta, 0, 12) // 12 Atomics.load(ta, 0) // 12 Atomics.exchange() 将数组中指定的元素更新为给定的值，并返回该元素更新前的值。 Atomics.exchange(typedArray, index, value) var sab = new SharedArrayBuffer(1024) var ta = new Uint8Array(sab) Atomics.exchange(ta, 0, 12) // returns 0, the old value Atomics.load(ta, 0) // 12 Atomics.wait()，Atomics.notify() 这两个方法相当于锁内存，即在一个线程进行操作时，让其他线程休眠（建立锁），等到操作结束，再唤醒那些休眠的线程（解除锁）。 Atomics.wait(typedArray, index, value[, timeout]) typedArray 一个共享的 Int32Array。 index typedArray 中要唤醒的目标索引。 value 给定需要检测的位置索引的预期值。 timeout 可选，超时前等待的毫秒数。 Infinity, 如未提供该参数，将为无穷大。 Atomics.notify(typedArray, index, count) count 要通知的正在休眠的代理的数量。默认是 +Infinity。 返回值 一个 String 字符串，值为 \"ok\", \"not-equal\", 或 \"timed-out\" 三种之一。 如果 sharedArray[index] 不等于 value，就返回字符串 not-equal，否则就进入休眠。如果 Atomics.notify() 方法唤醒，就返回字符串 ok；如果因为超时唤醒，就返回字符串 timed-out。 // Worker 线程 self.addEventListener( 'message', (event) => { const sharedArray = new Int32Array(event.data) const arrayIndex = 0 const expectedStoredValue = 50 Atomics.wait(sharedArray, arrayIndex, expectedStoredValue) console.log(Atomics.load(sharedArray, arrayIndex)) }, false, ) 上面代码中，Atomics.wait() 方法等同于告诉 Worker 线程，只要满足给定条件（sharedArray 的 0 号位置等于 50），就在这一行 Worker 线程进入休眠。 // 主线程 const newArrayValue = 100 Atomics.store(sharedArray, 0, newArrayValue) const arrayIndex = 0 const queuePos = 1 Atomics.notify(sharedArray, arrayIndex, queuePos) 上面代码中，sharedArray 的 0 号位置改为 100，然后就执行 Atomics.notify()方法，唤醒在 sharedArray 的 0 号位置休眠队列里的一个线程。 注意，浏览器的主线程不宜设置休眠，这会导致用户失去响应。而且，主线程实际上会拒绝进入休眠。 Atomics.add() 将指定位置上的数组元素与给定的值相加，并返回相加前该元素的值。 Atomics.add(typedArray, index, value) var sab = new SharedArrayBuffer(1024) var ta = new Uint8Array(sab) Atomics.add(ta, 0, 12) // returns 0, the old value Atomics.load(ta, 0) // 12 Atomics.and() 将指定位置上的数组元素与给定的值相与，并返回与操作前该元素的值。 Atomics.and(typedArray, index, value) var sab = new SharedArrayBuffer(1024) var ta = new Uint8Array(sab) ta[0] = 5 Atomics.and(ta, 0, 1) // returns 0, the old value Atomics.load(ta, 0) // 1 Atomics.compareExchange() 如果数组中指定的元素与给定的值相等，则将其更新为新的值，并返回该元素原先的值。 Atomics.compareExchange(typedArray, index, expectedValue, replacementValue) expectedValue 用于比较的值。 replacementValue 将要替换上的值。 var sab = new SharedArrayBuffer(1024) var ta = new Uint8Array(sab) ta[0] = 7 Atomics.compareExchange(ta, 0, 7, 12) // returns 7, the old value Atomics.load(ta, 0) // 12 Atomics.isLockFree() 返回一个布尔值，表示 Atomics 对象是否可以处理某个 size 的内存锁定。如果返回 false，应用程序就需要自己来实现锁定。 Atomics.isLockFree(size) Atomics.isLockFree(1) // true Atomics.isLockFree(2) // true Atomics.isLockFree(3) // false Atomics.isLockFree(4) // true Atomics.isLockFree(5) // false Atomics.isLockFree(6) // false Atomics.isLockFree(7) // false Atomics.isLockFree(8) // false Atomics.isLockFree(Float64Array.BYTES_PER_ELEMENT) // false,Atomics方法无法处理Float64Array Atomics.or() 将指定位置上的数组元素与给定的值相或，并返回或操作前该元素的值。 Atomics.or(typedArray, index, value) var sab = new SharedArrayBuffer(1024) var ta = new Uint8Array(sab) ta[0] = 2 Atomics.or(ta, 0, 1) // returns 2, the old value Atomics.load(ta, 0) // 3 Atomics.sub() 将指定位置上的数组元素与给定的值相减，并返回相减前该元素的值。 Atomics.sub(typedArray, index, value) const sab = new SharedArrayBuffer(1024) const ta = new Uint8Array(sab) ta[0] = 48 Atomics.sub(ta, 0, 12) // returns 48, the old value Atomics.load(ta, 0) // 36 Atomics.xor() 将指定位置上的数组元素与给定的值相异或，并返回异或操作前该元素的值。 Atomics.xor(typedArray, index, value) const sab = new SharedArrayBuffer(1024) const ta = new Uint8Array(sab) ta[0] = 5 Atomics.xor(ta, 0, 1) // returns 5, the old value Atomics.load(ta, 0) // 4 参考 Shared memory and atomics for ECMAscriptArrayBuffer - ECMAScript 6 入门SharedArrayBufferAtomics Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2020-11-10 02:15:46 "},"es2017/object-values-entries.html":{"url":"es2017/object-values-entries.html","title":"Object.values / Object.entries","keywords":"","body":"Object.values / Object.entries 简介 在 Object 中，ES2017 新增了两个新的函数，分别是 Object.values 函数和 Object.entries 函数。 Object.values() 方法返回一个给定对象自身的所有可枚举属性值的数组，值的顺序与使用 for...in 循环的顺序相同（区别在于 for-in 循环枚举原型链中的属性）。 Object.entries() 方法返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for...in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环还会枚举原型链中的属性）。 两者枚举属性的顺序与通过手动循环对象的属性值所给出的顺序相同，如果属性名为数值的属性，是按照数值大小，从小到大遍历的。 语法 Object.values() 属性值为字符串 const obj = { foo: 'bar', baz: 'test' } Object.values(obj) // [\"bar\", \"test\"] 属性值为数字 const obj = { 666: 'a', 2: 'b', 8: 'c' } Object.values(obj) // [\"b\", \"c\", \"a\"] 上面例子中，属性名为数值，按照数值大小遍历，因此返回的顺序是 b、c、a。 只返回对象本身的可遍历属性 const obj = Object.create({}, { p: { value: 42 } }) Object.values(obj) // [] 上面代码中，Object.create 方法的第二个参数添加的对象属性 enumerable 默认是 false，Object.values 不会返回这个属性。只要把 enumerable 改成 true，Object.values 就会返回属性 p 的值。 const obj = Object.create( {}, { p: { value: 42, enumerable: true, }, }, ) Object.values(obj) // [42] 属性值为 Symbol Object.values({ [Symbol()]: 123, foo: 'abc' }) // ['abc'] Object.values 会过滤属性名为 Symbol 值的属性。 参数不是对象 如果 Object.values 方法的参数是一个字符串，会返回各个字符组成的一个数组。 Object.values('foo') // ['f', 'o', 'o'] 如果参数不是对象，Object.values 会先将其转为对象。 由于数值和布尔值的包装对象，都不会为实例添加非继承的属性。所以，Object.values 会返回空数组。 Object.values(42) // [] Object.values(true) // [] Object.entries() 除了返回值不一样，该方法的行为与 Object.values 基本一致。 遍历对象的属性 const obj = { a: 5, b: 7, c: 9 } for (const [key, value] of Object.entries(obj)) { console.log(`${key}: ${value}`) } // \"a: 5\", \"b: 7\", \"c: 9\" 将 Object 转为 Map 结构 new Map() 构造函数接受一个可迭代的 entries。借助 Object.entries 方法你可以很容易的将 Object 转换为 Map: var obj = { foo: 'bar', baz: 42 } var map = new Map(Object.entries(obj)) console.log(map) // Map { foo: \"bar\", baz: 42 } 参考 Objet.values()Object.entries()对象的新增方法 - ECMAScript 6 入门 Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2020-11-10 02:15:46 "},"es2017/string-pad-start-end.html":{"url":"es2017/string-pad-start-end.html","title":"String padding","keywords":"","body":"String padding 简介 在 String 对象中，ES2017 增加了两个新的函数，字符串补全长度功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart() 用于头部补全，padEnd() 用于尾部补全。 语法 str.padStart(targetLength [, padString])str.padEnd(targetLength [, padString]) 参数： targetLength：当前字符串需要填充到的目标长度。如果这个数值小于当前字符串的长度，则返回当前字符串本身。 padString：可选，填充字符串。此参数的默认值为 \" \"。 返回值： 在原字符串开头填充指定的填充字符串直到目标长度所形成的新字符串。 实例 原字符串的长度，等于或大于最大长度，则字符串补全不生效，返回原字符串。 'xxx'.padStart(2, 'ab') // 'xxx' 'xxx'.padEnd(2, 'ab') // 'xxx' 如果用来补全的字符串与原字符串，两者的长度之和超过了最大长度，则会截去超出位数的补全字符串。 'abc'.padStart(10, '0123456789') // '0123456abc' 如果省略第二个参数，默认使用空格补全长度。 'x'.padStart(4) // ' x' 'x'.padEnd(4) // 'x ' 参考 String.prototype.padStart / String.prototype.padEnd Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2020-11-10 02:15:46 "},"es2017/trailing-function-commas.html":{"url":"es2017/trailing-function-commas.html","title":"Trailing comma","keywords":"","body":"函数参数列表结尾允许逗号 简介 ES2017 允许函数的最后一个参数有尾逗号（trailing comma）。此前，函数定义和调用时，都不允许最后一个参数后面出现逗号。 语法 function clownPuppiesEverywhere( param1, + param2 // this line ) { /* ... */ } clownPuppiesEverywhere( 'foo', + 'bar' // this line ) 上面代码中，如果修改代码添加第三个参数，或者调整参数的次序，就要在原来最后一个参数的后面添加逗号，对于版本管理来说，就会显示添加逗号的那一行发生了变动。看上去又写冗余。 function clownPuppiesEverywhere( param1, param2, // this line ) { /* ... */ } clownPuppiesEverywhere( 'foo', 'bar', // this line ) 这样的规定也使得，函数参数与数组和对象的尾逗号规则，保持一致了。 参考 Proposal to allow trailing commas in function parameter lists Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2020-11-10 02:15:46 "},"es2017/object-getownpropertydescriptors.html":{"url":"es2017/object-getownpropertydescriptors.html","title":"Object.getOwnPropertyDescriptors","keywords":"","body":"Object.getOwnPropertyDescriptors 简介 ES5 的 Object.getOwnPropertyDescriptor() 方法会返回某个对象属性的描述对象（descriptor）。ES2017 引入了 Object.getOwnPropertyDescriptors() 方法，返回指定对象所有自身属性（非继承属性）的描述对象。 语法 基本用法如下。 const obj = { foo: 123, get bar() { return 'abc' }, } Object.getOwnPropertyDescriptors(obj) // { foo: // { value: 123, // writable: true, // enumerable: true, // configurable: true }, // bar: // { get: [Function: get bar], // set: undefined, // enumerable: true, // configurable: true } } 该方法的实现非常容易。 function getOwnPropertyDescriptors(obj) { const result = {} for (let key of Reflect.ownKeys(obj)) { result[key] = Object.getOwnPropertyDescriptor(obj, key) } return result } 该方法引入的目的，主要是为了解决 Object.assign() 无法正确拷贝 get 属性和 set 属性的问题。Object.assign 方法总是拷贝一个属性的值，而不会拷贝它背后的赋值方法或取值方法。 这时，Object.getOwnPropertyDescriptors() 方法配合 Object.defineProperties() 方法，就可以实现正确拷贝。 const source = { set foo(value) { console.log(value) }, } const target2 = {} Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source)) Object.getOwnPropertyDescriptor(target2, 'foo') // { get: undefined, // set: [Function: set foo], // enumerable: true, // configurable: true } 实例 浅拷贝一个对象 配合 Object.create() 方法，将对象属性克隆到一个新对象。 Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj)) 创建子类 创建子类的典型方法是定义子类，将其原型设置为超类的实例，然后在该实例上定义属性。这么写很不优雅，特别是对于 getters 和 setter 而言。可以下面方式设置原型： function superclass() {} superclass.prototype = { // 在这里定义方法和属性 } function subclass() {} subclass.prototype = Object.create( superclass.prototype, Object.getOwnPropertyDescriptors({ // 在这里定义方法和属性 }), ) 参考 对象的新增方法 - ECMAScript 6 入门tc39/Object.getOwnPropertyDescriptors Copyright © 零度实验室 2020 all right reserved，powered by Gitbook修订时间： 2020-11-10 02:15:46 "}}